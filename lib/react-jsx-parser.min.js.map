{"version":3,"sources":["webpack://react-jsx-parser/webpack/universalModuleDefinition","webpack://react-jsx-parser/webpack/bootstrap","webpack://react-jsx-parser/external \"react\"","webpack://react-jsx-parser/./node_modules/acorn-jsx/index.js","webpack://react-jsx-parser/./node_modules/acorn-jsx/inject.js","webpack://react-jsx-parser/./node_modules/acorn-jsx/xhtml.js","webpack://react-jsx-parser/./node_modules/acorn/dist/acorn.es.js","webpack://react-jsx-parser/./source/constants/attributeNames.js","webpack://react-jsx-parser/./source/constants/specialTags.js","webpack://react-jsx-parser/./source/helpers/hash.js","webpack://react-jsx-parser/./source/helpers/parseStyle.js","webpack://react-jsx-parser/./source/helpers/camelCase.js","webpack://react-jsx-parser/./source/helpers/resolvePath.js","webpack://react-jsx-parser/./source/components/JsxParser.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","XHTMLEntities","hexNumber","decimalNumber","acorn","tt","tokTypes","tc","tokContexts","j_oTag","TokContext","j_cTag","j_expr","jsxName","TokenType","jsxText","beforeExpr","jsxTagStart","jsxTagEnd","updateContext","context","push","exprAllowed","prevType","out","pop","slash","curContext","pp","Parser","getQualifiedJSXName","type","namespace","jsx_readToken","chunkStart","pos","input","length","raise","start","ch","charCodeAt","finishToken","getTokenFromCode","slice","jsx_readEntity","isNewLine","jsx_readNewLine","normalizeCRLF","String","fromCharCode","options","locations","curLine","lineStart","jsx_readString","quote","string","entity","str","count","startPos","substr","test","parseInt","jsx_readWord","isIdentifierChar","jsx_parseIdentifier","node","startNode","keyword","unexpected","next","finishNode","jsx_parseNamespacedName","startLoc","plugins","jsx","allowNamespaces","eat","colon","startNodeAt","jsx_parseElementName","dot","allowNamespacedObjects","newNode","jsx_parseAttributeValue","braceL","jsx_parseExpressionContainer","expression","parseExprAtom","jsx_parseEmptyExpression","lastTokEnd","lastTokEndLoc","finishNodeAt","braceR","parseExpression","expect","jsx_parseAttribute","ellipsis","argument","parseMaybeAssign","eq","jsx_parseOpeningElementAt","attributes","nodeName","selfClosing","jsx_parseClosingElementAt","jsx_parseElementAt","children","openingElement","closingElement","contents","relational","jsx_parseText","parseLiteral","jsx_parseElement","instance","opts","extend","inner","refShortHandDefaultPos","code","isIdentifierStart","b_expr","b_tmpl","quot","amp","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","reservedWords","3","5","6","strict","strictBind","ecma5AndLessKeywords","keywords","keywordRelationalOperator","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","set","astral","label","conf","startsExpr","isLoop","isAssign","prefix","postfix","binop","prec","keywords$1","kw","types","num","regexp","eof","bracketL","bracketR","parenL","parenR","comma","semi","question","arrow","template","invalidTemplate","backQuote","dollarBraceL","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","bitShift","plusMin","modulo","star","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","source","ecma2019String","nonASCIIwhitespace","skipWhiteSpace","ref","toString","has","obj","propName","isArray","Array","Position","line","col","column","offset","SourceLocation","end","sourceFile","getLineInfo","cur","lastIndex","match","exec","index","defaultOptions","ecmaVersion","sourceType","onInsertedSemicolon","onTrailingComma","allowReserved","allowReturnOutsideFunction","allowImportExportEverywhere","allowAwaitOutsideFunction","allowHashBang","onToken","onComment","ranges","program","directSourceFile","preserveParens","getOptions","opt","tokens","token","array","block","text","endLoc","comment","loc","range","pushComment","keywordRegexp","words","replace","reserved","v","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","lastIndexOf","split","curPosition","lastTokStartLoc","lastTokStart","initialContext","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","scopeStack","enterFunctionScope","regexpState","isKeyword","word","isReservedWord","f","pluginConfigs","plugin","Error","parse","nextToken","parseTopLevel","literal","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","doubleProto","isContextual","eatContextual","expectContextual","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","expr","pp$1","body","stmt","parseStatement","adaptDirectivePrologue","loopLabel","kind","switchLabel","isLet","skip","nextCh","ident","isAsyncFunction","charAt","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","parseParenExpression","awaitAt","enterLexicalScope","parseFor","init$1","parseVar","declarations","init","await","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","consequent","alternate","discriminant","cases","sawDefault","isCase","exitLexicalScope","handler","clause","param","parseBindingAtom","finalizer","i$1","list","label$1","statementStart","generator","async","createNewLexicalScope","update","id","left","right","isFor","decl","parseVarId","isStatement","allowExpressionBody","initFunction","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","params","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","member","parseClassMember","this$1","method","tryContextual","k","noLineBreak","computed","static","isGenerator","parsePropertyName","parseClassMethod","parseMethod","superClass","parseExprSubscripts","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","spec","checkUnreserved","local","checkPatternExport","pat","properties","list$1","elements","elt","decls","nodes","first","exported","parseImportSpecifiers","node$1","node$2","imported","statements","isDirectiveCandidate","directive","raw","statement","pp$2","isBinding","toAssignableList","operator","exprList","last","parseSpread","parseRestBinding","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","bindingType","checkClashes","canDeclareVarName","canDeclareLexicalName","declareVarName","declareLexicalName","pp$3","checkPropClash","propHash","shorthand","proto","other","noIn","expressions","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","op","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","result","parseSubscripts","base","noCalls","maybeAsyncArrow","parseExprList","parseArrowExpression","callee","arguments","tag","quasi","parseTemplate","isTagged","canBeArrow","regex","pattern","flags","parseParenAndDistinguishExpression","parseNew","val","spreadStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","par","item","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isAsyncProp","isPattern","parseProperty","parsePropertyValue","paramCount","isArrowFunction","isExpression","oldStrict","useStrict","checkParams","nonSimple","isSimpleParamList","oldLabels","exitFunctionScope","allowDuplicates","nameHash","indexOf","liberal","delegate","pp$4","message","err","SyntaxError","raisedAt","pp$5","target","sources","len","var","lexical","childVar","parentLexical","parentScope","childScope","currentScope","Node","parser","pp$6","isExpr","preserveSpace","override","types$1","b_stat","p_stat","p_expr","q_tmpl","tryReadTemplateToken","f_stat","f_expr","f_expr_gen","f_gen","pp$7","braceIsBlock","parent","inGeneratorContext","statementParens","allowed","data","apply","$LONE","General_Category","gc","sc","Script_Extensions","scx","Script","pp$9","RegExpValidationState","validFlags","switchU","switchN","lastIntValue","lastStringValue","lastAssertionIsQuantifiable","numCapturingParens","maxBackReference","groupNames","backReferenceNames","codePointToString$1","isSyntaxCharacter","isControlLetter","isUnicodePropertyNameCharacter","isUnicodePropertyValueCharacter","isDecimalDigit","isHexDigit","hexToInt","isOctalDigit","reset","unicode","at","nextIndex","current","lookahead","advance","validateRegExpFlags","state","flag","validateRegExpPattern","regexp_pattern","regexp_disjunction","regexp_alternative","regexp_eatQuantifier","regexp_eatTerm","regexp_eatAssertion","regexp_eatAtom","regexp_eatExtendedAtom","lookbehind","noError","regexp_eatQuantifierPrefix","regexp_eatBracedQuantifier","min","max","regexp_eatDecimalDigits","regexp_eatPatternCharacters","regexp_eatReverseSolidusAtomEscape","regexp_eatCharacterClass","regexp_eatUncapturingGroup","regexp_eatCapturingGroup","regexp_eatAtomEscape","regexp_groupSpecifier","regexp_eatInvalidBracedQuantifier","regexp_eatExtendedPatternCharacter","regexp_eatSyntaxCharacter","regexp_eatGroupName","regexp_eatRegExpIdentifierName","regexp_eatRegExpIdentifierStart","regexp_eatRegExpIdentifierPart","regexp_eatRegExpUnicodeEscapeSequence","isRegExpIdentifierStart","isRegExpIdentifierPart","regexp_eatBackReference","regexp_eatCharacterClassEscape","regexp_eatCharacterEscape","regexp_eatKGroupName","regexp_eatDecimalEscape","regexp_eatControlEscape","regexp_eatCControlLetter","regexp_eatZero","regexp_eatHexEscapeSequence","regexp_eatLegacyOctalEscapeSequence","regexp_eatIdentityEscape","regexp_eatControlLetter","regexp_eatFixedHexDigits","lead","leadSurrogateEnd","trail","regexp_eatHexDigits","isCharacterClassEscape","regexp_eatUnicodePropertyValueExpression","regexp_eatUnicodePropertyName","regexp_eatUnicodePropertyValue","regexp_validateUnicodePropertyNameAndValue","regexp_eatLoneUnicodePropertyNameOrValue","nameOrValue","regexp_validateUnicodePropertyNameOrValue","regexp_classRanges","regexp_eatClassAtom","regexp_eatClassEscape","ch$1","regexp_eatClassControlLetter","regexp_eatOctalDigit","n1","n2","Token","pp$8","codePointToString","getToken","iterator","done","skipSpace","readToken","fullCharCodeAtPos","readWord","skipBlockComment","startSkip","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo_exp","size","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","escaped","inClass","flagsStart","readWord1","e","readInt","radix","total","Infinity","startsWithDot","octal","parseFloat","readCodePoint","codePos","readHexChar","invalidStringToken","readEscapedChar","INVALID_TEMPLATE_ESCAPE_ERROR","inTemplateElement","readTmplToken","readInvalidTemplateToken","position","inTemplate","octalStr","escStart","esc","parse_dammit","LooseParser","pluginsLoose","version","parseExpressionAt","tokenizer","addLooseExports","Parser$$1","plugins$$1","class","for","maxlength","colspan","rowspan","VOID_ELEMENTS","NO_WHITESPACE","canHaveChildren","tagName","toLowerCase","canHaveWhitespace","randomHash","h","forEach","char","Math","abs","hash","random","parseStyle","style","filter","reduce","map","rule","trim","toUpperCase","join","path","resolveArrayPath","subPath","pathToArrayPath","parserOptions","JsxParser","rawJSX","wrappedJsx","parsed","error","props","showWarnings","console","warn","onError","Boolean","log","parseElement","disableKeyGeneration","undefined","disableFragments","bindings","parsedCallee","element","parseName","allowUnknownElements","components","componentsOnly","childNodes","blacklistedAttrs","attr","blacklistedTags","resolvePath","document","createElement","HTMLUnknownElement","component","child","rawName","attributeName","ATTRIBUTES","re","keys","React","ParsedChildren","parseJSX","renderInWrapper","className","Component"],"mappings":"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,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,KAAK,GAAG,IAAI,KAAK,IAAI,GAAG,IAAI,KAAK,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,KAAK,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,KAAK,IAAI,GAAG,GAAG,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG,KAAK,KAAK,KAG7pCC,EAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,GAAG,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,KAAK,GAAG,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,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,UAAUnZ,cAAgB,WAC1BvD,KAAK+D,eAAiBg0B,GAAQI,OAC9Bn4B,KAAKwD,QAAQK,MAEb7D,KAAKwD,QAAQC,KAAKs0B,GAAQI,QAC9Bn4B,KAAK0D,aAAc,GAGrBkY,EAAM2B,KAAKha,cAAgB,SAASI,GAClC,GAAIA,IAAaiY,EAAMuC,UAAW,CAChC,IAAImD,EAAQthB,KAAKwD,QAAQiB,OAAS,EAC9BzE,KAAKwD,QAAQ8d,KAAWyW,GAAQO,OAChCt4B,KAAKwD,QAAQ8d,GAASyW,GAAQQ,WAE9Bv4B,KAAKwD,QAAQ8d,GAASyW,GAAQS,MAEpCx4B,KAAK0D,aAAc,GAGrBkY,EAAMhb,KAAK2C,cAAgB,SAASI,GAClC,IAAIm1B,GAAU,EACV94B,KAAKuF,QAAQic,aAAe,GAAK7d,IAAaiY,EAAMrU,MACnC,OAAfvH,KAAKsB,QAAmBtB,KAAK0D,aACd,UAAf1D,KAAKsB,OAAqBtB,KAAK44B,wBAC/BE,GAAU,GAEhB94B,KAAK0D,YAAco1B,GAGrB,IAAIC,GAAO,CACT,MAAS,CACP,QACA,kBACA,OACA,aACA,QACA,MACA,WACA,eACA,SACA,gBACA,SACA,iBACA,KACA,QACA,0BACA,OACA,0BACA,OACA,0BACA,MACA,+BACA,QACA,0BACA,MACA,0BACA,MACA,OACA,+BACA,KACA,aACA,MACA,YACA,MACA,QACA,kBACA,iBACA,sBACA,qBACA,WACA,MACA,gBACA,UACA,kBACA,SACA,YACA,MACA,sBACA,OACA,uBACA,OACA,cACA,MACA,WACA,MACA,cACA,OACA,eACA,SACA,0BACA,MACA,YACA,QACA,OACA,0BACA,QACA,iBACA,UACA,sBACA,SACA,iBACA,QACA,UACA,qBACA,KACA,oBACA,QACA,cACA,KACA,uBACA,OACA,oBACA,QACA,YACA,QACA,qBACA,KACA,cACA,QACA,eACA,OACA,YACA,QAEF,iBAAoB,CAClB,eACA,KACA,oBACA,KACA,wBACA,KACA,UACA,KACA,QACA,kBACA,KACA,mBACA,KACA,iBACA,KACA,QACA,iBACA,KACA,oBACA,KACA,SACA,KACA,sBACA,KACA,SACA,IACA,gBACA,KACA,iBACA,KACA,mBACA,KACA,OACA,IACA,iBACA,cACA,KACA,kBACA,KACA,kBACA,KACA,kBACA,KACA,SACA,IACA,mBACA,KACA,QACA,IACA,eACA,KACA,eACA,KACA,oBACA,KACA,eACA,KACA,sBACA,KACA,cACA,KACA,cACA,IACA,QACA,YACA,IACA,kBACA,KACA,eACA,KACA,YACA,KACA,SACA,IACA,mBACA,KACA,aACA,KACA,mBACA,MAEF,OAAU,CACR,QACA,OACA,OACA,wBACA,OACA,SACA,OACA,WACA,OACA,UACA,OACA,WACA,OACA,QACA,OACA,YACA,OACA,QACA,OACA,UACA,OACA,YACA,OACA,WACA,OACA,SACA,OACA,UACA,OACA,WACA,OACA,QACA,OACA,sBACA,OACA,SACA,OACA,qBACA,OACA,SACA,OACA,OACA,WACA,OACA,SACA,OACA,SACA,OACA,OACA,YACA,OACA,UACA,OACA,WACA,OACA,UACA,OACA,aACA,OACA,WACA,OACA,uBACA,OACA,UACA,OACA,WACA,OACA,WACA,OACA,aACA,OACA,SACA,OACA,UACA,OACA,QACA,OACA,WACA,OACA,WACA,OACA,MACA,OACA,SACA,OACA,UACA,OACA,SACA,OACA,SACA,OACA,WACA,OACA,mBACA,OACA,YACA,OACA,OACA,wBACA,OACA,yBACA,OACA,WACA,OACA,SACA,OACA,UACA,OACA,WACA,OACA,WACA,OACA,aACA,OACA,QACA,OACA,SACA,OACA,YACA,OACA,MACA,OACA,QACA,OACA,SACA,OACA,QACA,OACA,WACA,OACA,WACA,OACA,OACA,SACA,OACA,SACA,OACA,WACA,OACA,YACA,OACA,UACA,OACA,aACA,OACA,UACA,OACA,gBACA,OACA,eACA,OACA,gBACA,OACA,mBACA,OACA,uBACA,OACA,OACA,OACA,OACA,YACA,OACA,MACA,OACA,UACA,OACA,UACA,OACA,YACA,OACA,cACA,OACA,OACA,MACA,OACA,QACA,OACA,QACA,OACA,WACA,OACA,gBACA,OACA,aACA,OACA,oBACA,OACA,aACA,OACA,cACA,OACA,oBACA,OACA,aACA,OACA,QACA,OACA,QACA,OACA,UACA,OACA,eACA,OACA,YACA,OACA,cACA,OACA,WACA,OACA,aACA,OACA,kBACA,OACA,SACA,OACA,QACA,OACA,YACA,OACA,aACA,OACA,UACA,OACA,UACA,OACA,UACA,OACA,cACA,OACA,UACA,OACA,eACA,OACA,UACA,OACA,YACA,OACA,eACA,OACA,SACA,OACA,UACA,OACA,WACA,OACA,SACA,OACA,WACA,OACA,WACA,OACA,QACA,OACA,QACA,OACA,SACA,OACA,SACA,OACA,SACA,OACA,OACA,UACA,OACA,WACA,OACA,UACA,OACA,WACA,OACA,MACA,OACA,cACA,OACA,KACA,OACA,mBACA,SAGJvY,MAAMve,UAAUwB,KAAKu1B,MAAMD,GAAKE,MAAOF,GAAKG,kBAC5CH,GAAKI,GAAKJ,GAAKG,iBACfH,GAAKK,GAAKL,GAAKM,kBAAoBN,GAAKO,IAAMP,GAAKQ,OAEnD,IAAIC,GAAOv1B,EAAOhC,UAEdw3B,GAAwB,SAA+B/B,GACzD13B,KAAK03B,OAASA,EACd13B,KAAK05B,WAAa,OAAShC,EAAOnyB,QAAQic,aAAe,EAAI,KAAO,KAAOkW,EAAOnyB,QAAQic,aAAe,EAAI,IAAM,IACnHxhB,KAAK8f,OAAS,GACd9f,KAAKi0B,MAAQ,GACbj0B,KAAK2E,MAAQ,EACb3E,KAAK25B,SAAU,EACf35B,KAAK45B,SAAU,EACf55B,KAAKuE,IAAM,EACXvE,KAAK65B,aAAe,EACpB75B,KAAK85B,gBAAkB,GACvB95B,KAAK+5B,6BAA8B,EACnC/5B,KAAKg6B,mBAAqB,EAC1Bh6B,KAAKi6B,iBAAmB,EACxBj6B,KAAKk6B,WAAa,GAClBl6B,KAAKm6B,mBAAqB,IAgE5B,SAASC,GAAoBx1B,GAC3B,OAAIA,GAAM,MAAiBS,OAAOC,aAAaV,IAC/CA,GAAM,MACCS,OAAOC,aAA0B,OAAZ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","file":"react-jsx-parser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"react-jsx-parser\", [\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"react-jsx-parser\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"react-jsx-parser\"] = factory(root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","'use strict';\n\nmodule.exports = require('./inject')(require('acorn'));\n","'use strict';\n\nvar XHTMLEntities = require('./xhtml');\n\nvar hexNumber = /^[\\da-fA-F]+$/;\nvar decimalNumber = /^\\d+$/;\n\nmodule.exports = function(acorn) {\n  var tt = acorn.tokTypes;\n  var tc = acorn.tokContexts;\n\n  tc.j_oTag = new acorn.TokContext('<tag', false);\n  tc.j_cTag = new acorn.TokContext('</tag', false);\n  tc.j_expr = new acorn.TokContext('<tag>...</tag>', true, true);\n\n  tt.jsxName = new acorn.TokenType('jsxName');\n  tt.jsxText = new acorn.TokenType('jsxText', {beforeExpr: true});\n  tt.jsxTagStart = new acorn.TokenType('jsxTagStart');\n  tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd');\n\n  tt.jsxTagStart.updateContext = function() {\n    this.context.push(tc.j_expr); // treat as beginning of JSX expression\n    this.context.push(tc.j_oTag); // start opening tag context\n    this.exprAllowed = false;\n  };\n  tt.jsxTagEnd.updateContext = function(prevType) {\n    var out = this.context.pop();\n    if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) {\n      this.context.pop();\n      this.exprAllowed = this.curContext() === tc.j_expr;\n    } else {\n      this.exprAllowed = true;\n    }\n  };\n\n  var pp = acorn.Parser.prototype;\n\n  // Reads inline JSX contents token.\n\n  pp.jsx_readToken = function() {\n    var out = '', chunkStart = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length)\n        this.raise(this.start, 'Unterminated JSX contents');\n      var ch = this.input.charCodeAt(this.pos);\n\n      switch (ch) {\n      case 60: // '<'\n      case 123: // '{'\n        if (this.pos === this.start) {\n          if (ch === 60 && this.exprAllowed) {\n            ++this.pos;\n            return this.finishToken(tt.jsxTagStart);\n          }\n          return this.getTokenFromCode(ch);\n        }\n        out += this.input.slice(chunkStart, this.pos);\n        return this.finishToken(tt.jsxText, out);\n\n      case 38: // '&'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.jsx_readEntity();\n        chunkStart = this.pos;\n        break;\n\n      default:\n        if (acorn.isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(true);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n    }\n  };\n\n  pp.jsx_readNewLine = function(normalizeCRLF) {\n    var ch = this.input.charCodeAt(this.pos);\n    var out;\n    ++this.pos;\n    if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n      ++this.pos;\n      out = normalizeCRLF ? '\\n' : '\\r\\n';\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    if (this.options.locations) {\n      ++this.curLine;\n      this.lineStart = this.pos;\n    }\n\n    return out;\n  };\n\n  pp.jsx_readString = function(quote) {\n    var out = '', chunkStart = ++this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length)\n        this.raise(this.start, 'Unterminated string constant');\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === quote) break;\n      if (ch === 38) { // '&'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.jsx_readEntity();\n        chunkStart = this.pos;\n      } else if (acorn.isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.jsx_readNewLine(false);\n        chunkStart = this.pos;\n      } else {\n        ++this.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(tt.string, out);\n  };\n\n  pp.jsx_readEntity = function() {\n    var str = '', count = 0, entity;\n    var ch = this.input[this.pos];\n    if (ch !== '&')\n      this.raise(this.pos, 'Entity must start with an ampersand');\n    var startPos = ++this.pos;\n    while (this.pos < this.input.length && count++ < 10) {\n      ch = this.input[this.pos++];\n      if (ch === ';') {\n        if (str[0] === '#') {\n          if (str[1] === 'x') {\n            str = str.substr(2);\n            if (hexNumber.test(str))\n              entity = String.fromCharCode(parseInt(str, 16));\n          } else {\n            str = str.substr(1);\n            if (decimalNumber.test(str))\n              entity = String.fromCharCode(parseInt(str, 10));\n          }\n        } else {\n          entity = XHTMLEntities[str];\n        }\n        break;\n      }\n      str += ch;\n    }\n    if (!entity) {\n      this.pos = startPos;\n      return '&';\n    }\n    return entity;\n  };\n\n\n  // Read a JSX identifier (valid tag or attribute name).\n  //\n  // Optimized version since JSX identifiers can't contain\n  // escape characters and so can be read as single slice.\n  // Also assumes that first character was already checked\n  // by isIdentifierStart in readToken.\n\n  pp.jsx_readWord = function() {\n    var ch, start = this.pos;\n    do {\n      ch = this.input.charCodeAt(++this.pos);\n    } while (acorn.isIdentifierChar(ch) || ch === 45); // '-'\n    return this.finishToken(tt.jsxName, this.input.slice(start, this.pos));\n  };\n\n  // Transforms JSX element name to string.\n\n  function getQualifiedJSXName(object) {\n    if (!object)\n      return object;\n\n    if (object.type === 'JSXIdentifier')\n      return object.name;\n\n    if (object.type === 'JSXNamespacedName')\n      return object.namespace.name + ':' + object.name.name;\n\n    if (object.type === 'JSXMemberExpression')\n      return getQualifiedJSXName(object.object) + '.' +\n      getQualifiedJSXName(object.property);\n  }\n\n  // Parse next token as JSX identifier\n\n  pp.jsx_parseIdentifier = function() {\n    var node = this.startNode();\n    if (this.type === tt.jsxName)\n      node.name = this.value;\n    else if (this.type.keyword)\n      node.name = this.type.keyword;\n    else\n      this.unexpected();\n    this.next();\n    return this.finishNode(node, 'JSXIdentifier');\n  };\n\n  // Parse namespaced identifier.\n\n  pp.jsx_parseNamespacedName = function() {\n    var startPos = this.start, startLoc = this.startLoc;\n    var name = this.jsx_parseIdentifier();\n    if (!this.options.plugins.jsx.allowNamespaces || !this.eat(tt.colon)) return name;\n    var node = this.startNodeAt(startPos, startLoc);\n    node.namespace = name;\n    node.name = this.jsx_parseIdentifier();\n    return this.finishNode(node, 'JSXNamespacedName');\n  };\n\n  // Parses element name in any form - namespaced, member\n  // or single identifier.\n\n  pp.jsx_parseElementName = function() {\n    if (this.type === tt.jsxTagEnd)\n      return '';\n    var startPos = this.start, startLoc = this.startLoc;\n    var node = this.jsx_parseNamespacedName();\n    if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !this.options.plugins.jsx.allowNamespacedObjects) {\n      this.unexpected();\n    }\n    while (this.eat(tt.dot)) {\n      var newNode = this.startNodeAt(startPos, startLoc);\n      newNode.object = node;\n      newNode.property = this.jsx_parseIdentifier();\n      node = this.finishNode(newNode, 'JSXMemberExpression');\n    }\n    return node;\n  };\n\n  // Parses any type of JSX attribute value.\n\n  pp.jsx_parseAttributeValue = function() {\n    switch (this.type) {\n    case tt.braceL:\n      var node = this.jsx_parseExpressionContainer();\n      if (node.expression.type === 'JSXEmptyExpression')\n        this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n      return node;\n\n    case tt.jsxTagStart:\n    case tt.string:\n      return this.parseExprAtom();\n\n    default:\n      this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n    }\n  };\n\n  // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n  // and so it should start at the end of last read token (left brace) and finish\n  // at the beginning of the next one (right brace).\n\n  pp.jsx_parseEmptyExpression = function() {\n    var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n    return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n  };\n\n  // Parses JSX expression enclosed into curly brackets.\n\n\n  pp.jsx_parseExpressionContainer = function() {\n    var node = this.startNode();\n    this.next();\n    node.expression = this.type === tt.braceR\n      ? this.jsx_parseEmptyExpression()\n      : this.parseExpression();\n    this.expect(tt.braceR);\n    return this.finishNode(node, 'JSXExpressionContainer');\n  };\n\n  // Parses following JSX attribute name-value pair.\n\n  pp.jsx_parseAttribute = function() {\n    var node = this.startNode();\n    if (this.eat(tt.braceL)) {\n      this.expect(tt.ellipsis);\n      node.argument = this.parseMaybeAssign();\n      this.expect(tt.braceR);\n      return this.finishNode(node, 'JSXSpreadAttribute');\n    }\n    node.name = this.jsx_parseNamespacedName();\n    node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n    return this.finishNode(node, 'JSXAttribute');\n  };\n\n  // Parses JSX opening tag starting after '<'.\n\n  pp.jsx_parseOpeningElementAt = function(startPos, startLoc) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.attributes = [];\n    var nodeName = this.jsx_parseElementName();\n    if (nodeName) node.name = nodeName;\n    while (this.type !== tt.slash && this.type !== tt.jsxTagEnd)\n      node.attributes.push(this.jsx_parseAttribute());\n    node.selfClosing = this.eat(tt.slash);\n    this.expect(tt.jsxTagEnd);\n    return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n  };\n\n  // Parses JSX closing tag starting after '</'.\n\n  pp.jsx_parseClosingElementAt = function(startPos, startLoc) {\n    var node = this.startNodeAt(startPos, startLoc);\n    var nodeName = this.jsx_parseElementName();\n    if (nodeName) node.name = nodeName;\n    this.expect(tt.jsxTagEnd);\n    return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n  };\n\n  // Parses entire JSX element, including it's opening tag\n  // (starting after '<'), attributes, contents and closing tag.\n\n  pp.jsx_parseElementAt = function(startPos, startLoc) {\n    var node = this.startNodeAt(startPos, startLoc);\n    var children = [];\n    var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n    var closingElement = null;\n\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.type) {\n        case tt.jsxTagStart:\n          startPos = this.start; startLoc = this.startLoc;\n          this.next();\n          if (this.eat(tt.slash)) {\n            closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n            break contents;\n          }\n          children.push(this.jsx_parseElementAt(startPos, startLoc));\n          break;\n\n        case tt.jsxText:\n          children.push(this.parseExprAtom());\n          break;\n\n        case tt.braceL:\n          children.push(this.jsx_parseExpressionContainer());\n          break;\n\n        default:\n          this.unexpected();\n        }\n      }\n      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n        this.raise(\n          closingElement.start,\n          'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n      }\n    }\n\n    node.openingElement = openingElement;\n    node.closingElement = closingElement;\n    node.children = children;\n    if (this.type === tt.relational && this.value === \"<\") {\n      this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n    }\n    return this.finishNode(node, openingElement.name ? 'JSXElement' : 'JSXFragment');\n  };\n\n  // Parse JSX text\n\n  pp.jsx_parseText = function(value) {\n    var node = this.parseLiteral(value);\n    node.type = \"JSXText\";\n\n    return node;\n  };\n\n  // Parses entire JSX element from current position.\n\n  pp.jsx_parseElement = function() {\n    var startPos = this.start, startLoc = this.startLoc;\n    this.next();\n    return this.jsx_parseElementAt(startPos, startLoc);\n  };\n\n  acorn.plugins.jsx = function(instance, opts) {\n    if (!opts) {\n      return;\n    }\n\n    if (typeof opts !== 'object') {\n      opts = {};\n    }\n\n    instance.options.plugins.jsx = {\n      allowNamespaces: opts.allowNamespaces !== false,\n      allowNamespacedObjects: !!opts.allowNamespacedObjects\n    };\n\n    instance.extend('parseExprAtom', function(inner) {\n      return function(refShortHandDefaultPos) {\n        if (this.type === tt.jsxText)\n          return this.jsx_parseText(this.value);\n        else if (this.type === tt.jsxTagStart)\n          return this.jsx_parseElement();\n        else\n          return inner.call(this, refShortHandDefaultPos);\n      };\n    });\n\n    instance.extend('readToken', function(inner) {\n      return function(code) {\n        var context = this.curContext();\n\n        if (context === tc.j_expr) return this.jsx_readToken();\n\n        if (context === tc.j_oTag || context === tc.j_cTag) {\n          if (acorn.isIdentifierStart(code)) return this.jsx_readWord();\n\n          if (code == 62) {\n            ++this.pos;\n            return this.finishToken(tt.jsxTagEnd);\n          }\n\n          if ((code === 34 || code === 39) && context == tc.j_oTag)\n            return this.jsx_readString(code);\n        }\n\n        if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n          ++this.pos;\n          return this.finishToken(tt.jsxTagStart);\n        }\n        return inner.call(this, code);\n      };\n    });\n\n    instance.extend('updateContext', function(inner) {\n      return function(prevType) {\n        if (this.type == tt.braceL) {\n          var curContext = this.curContext();\n          if (curContext == tc.j_oTag) this.context.push(tc.b_expr);\n          else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl);\n          else inner.call(this, prevType);\n          this.exprAllowed = true;\n        } else if (this.type === tt.slash && prevType === tt.jsxTagStart) {\n          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n          this.context.push(tc.j_cTag); // reconsider as closing tag context\n          this.exprAllowed = false;\n        } else {\n          return inner.call(this, prevType);\n        }\n      };\n    });\n  };\n\n  return acorn;\n};\n","module.exports = {\n  quot: '\\u0022',\n  amp: '&',\n  apos: '\\u0027',\n  lt: '<',\n  gt: '>',\n  nbsp: '\\u00A0',\n  iexcl: '\\u00A1',\n  cent: '\\u00A2',\n  pound: '\\u00A3',\n  curren: '\\u00A4',\n  yen: '\\u00A5',\n  brvbar: '\\u00A6',\n  sect: '\\u00A7',\n  uml: '\\u00A8',\n  copy: '\\u00A9',\n  ordf: '\\u00AA',\n  laquo: '\\u00AB',\n  not: '\\u00AC',\n  shy: '\\u00AD',\n  reg: '\\u00AE',\n  macr: '\\u00AF',\n  deg: '\\u00B0',\n  plusmn: '\\u00B1',\n  sup2: '\\u00B2',\n  sup3: '\\u00B3',\n  acute: '\\u00B4',\n  micro: '\\u00B5',\n  para: '\\u00B6',\n  middot: '\\u00B7',\n  cedil: '\\u00B8',\n  sup1: '\\u00B9',\n  ordm: '\\u00BA',\n  raquo: '\\u00BB',\n  frac14: '\\u00BC',\n  frac12: '\\u00BD',\n  frac34: '\\u00BE',\n  iquest: '\\u00BF',\n  Agrave: '\\u00C0',\n  Aacute: '\\u00C1',\n  Acirc: '\\u00C2',\n  Atilde: '\\u00C3',\n  Auml: '\\u00C4',\n  Aring: '\\u00C5',\n  AElig: '\\u00C6',\n  Ccedil: '\\u00C7',\n  Egrave: '\\u00C8',\n  Eacute: '\\u00C9',\n  Ecirc: '\\u00CA',\n  Euml: '\\u00CB',\n  Igrave: '\\u00CC',\n  Iacute: '\\u00CD',\n  Icirc: '\\u00CE',\n  Iuml: '\\u00CF',\n  ETH: '\\u00D0',\n  Ntilde: '\\u00D1',\n  Ograve: '\\u00D2',\n  Oacute: '\\u00D3',\n  Ocirc: '\\u00D4',\n  Otilde: '\\u00D5',\n  Ouml: '\\u00D6',\n  times: '\\u00D7',\n  Oslash: '\\u00D8',\n  Ugrave: '\\u00D9',\n  Uacute: '\\u00DA',\n  Ucirc: '\\u00DB',\n  Uuml: '\\u00DC',\n  Yacute: '\\u00DD',\n  THORN: '\\u00DE',\n  szlig: '\\u00DF',\n  agrave: '\\u00E0',\n  aacute: '\\u00E1',\n  acirc: '\\u00E2',\n  atilde: '\\u00E3',\n  auml: '\\u00E4',\n  aring: '\\u00E5',\n  aelig: '\\u00E6',\n  ccedil: '\\u00E7',\n  egrave: '\\u00E8',\n  eacute: '\\u00E9',\n  ecirc: '\\u00EA',\n  euml: '\\u00EB',\n  igrave: '\\u00EC',\n  iacute: '\\u00ED',\n  icirc: '\\u00EE',\n  iuml: '\\u00EF',\n  eth: '\\u00F0',\n  ntilde: '\\u00F1',\n  ograve: '\\u00F2',\n  oacute: '\\u00F3',\n  ocirc: '\\u00F4',\n  otilde: '\\u00F5',\n  ouml: '\\u00F6',\n  divide: '\\u00F7',\n  oslash: '\\u00F8',\n  ugrave: '\\u00F9',\n  uacute: '\\u00FA',\n  ucirc: '\\u00FB',\n  uuml: '\\u00FC',\n  yacute: '\\u00FD',\n  thorn: '\\u00FE',\n  yuml: '\\u00FF',\n  OElig: '\\u0152',\n  oelig: '\\u0153',\n  Scaron: '\\u0160',\n  scaron: '\\u0161',\n  Yuml: '\\u0178',\n  fnof: '\\u0192',\n  circ: '\\u02C6',\n  tilde: '\\u02DC',\n  Alpha: '\\u0391',\n  Beta: '\\u0392',\n  Gamma: '\\u0393',\n  Delta: '\\u0394',\n  Epsilon: '\\u0395',\n  Zeta: '\\u0396',\n  Eta: '\\u0397',\n  Theta: '\\u0398',\n  Iota: '\\u0399',\n  Kappa: '\\u039A',\n  Lambda: '\\u039B',\n  Mu: '\\u039C',\n  Nu: '\\u039D',\n  Xi: '\\u039E',\n  Omicron: '\\u039F',\n  Pi: '\\u03A0',\n  Rho: '\\u03A1',\n  Sigma: '\\u03A3',\n  Tau: '\\u03A4',\n  Upsilon: '\\u03A5',\n  Phi: '\\u03A6',\n  Chi: '\\u03A7',\n  Psi: '\\u03A8',\n  Omega: '\\u03A9',\n  alpha: '\\u03B1',\n  beta: '\\u03B2',\n  gamma: '\\u03B3',\n  delta: '\\u03B4',\n  epsilon: '\\u03B5',\n  zeta: '\\u03B6',\n  eta: '\\u03B7',\n  theta: '\\u03B8',\n  iota: '\\u03B9',\n  kappa: '\\u03BA',\n  lambda: '\\u03BB',\n  mu: '\\u03BC',\n  nu: '\\u03BD',\n  xi: '\\u03BE',\n  omicron: '\\u03BF',\n  pi: '\\u03C0',\n  rho: '\\u03C1',\n  sigmaf: '\\u03C2',\n  sigma: '\\u03C3',\n  tau: '\\u03C4',\n  upsilon: '\\u03C5',\n  phi: '\\u03C6',\n  chi: '\\u03C7',\n  psi: '\\u03C8',\n  omega: '\\u03C9',\n  thetasym: '\\u03D1',\n  upsih: '\\u03D2',\n  piv: '\\u03D6',\n  ensp: '\\u2002',\n  emsp: '\\u2003',\n  thinsp: '\\u2009',\n  zwnj: '\\u200C',\n  zwj: '\\u200D',\n  lrm: '\\u200E',\n  rlm: '\\u200F',\n  ndash: '\\u2013',\n  mdash: '\\u2014',\n  lsquo: '\\u2018',\n  rsquo: '\\u2019',\n  sbquo: '\\u201A',\n  ldquo: '\\u201C',\n  rdquo: '\\u201D',\n  bdquo: '\\u201E',\n  dagger: '\\u2020',\n  Dagger: '\\u2021',\n  bull: '\\u2022',\n  hellip: '\\u2026',\n  permil: '\\u2030',\n  prime: '\\u2032',\n  Prime: '\\u2033',\n  lsaquo: '\\u2039',\n  rsaquo: '\\u203A',\n  oline: '\\u203E',\n  frasl: '\\u2044',\n  euro: '\\u20AC',\n  image: '\\u2111',\n  weierp: '\\u2118',\n  real: '\\u211C',\n  trade: '\\u2122',\n  alefsym: '\\u2135',\n  larr: '\\u2190',\n  uarr: '\\u2191',\n  rarr: '\\u2192',\n  darr: '\\u2193',\n  harr: '\\u2194',\n  crarr: '\\u21B5',\n  lArr: '\\u21D0',\n  uArr: '\\u21D1',\n  rArr: '\\u21D2',\n  dArr: '\\u21D3',\n  hArr: '\\u21D4',\n  forall: '\\u2200',\n  part: '\\u2202',\n  exist: '\\u2203',\n  empty: '\\u2205',\n  nabla: '\\u2207',\n  isin: '\\u2208',\n  notin: '\\u2209',\n  ni: '\\u220B',\n  prod: '\\u220F',\n  sum: '\\u2211',\n  minus: '\\u2212',\n  lowast: '\\u2217',\n  radic: '\\u221A',\n  prop: '\\u221D',\n  infin: '\\u221E',\n  ang: '\\u2220',\n  and: '\\u2227',\n  or: '\\u2228',\n  cap: '\\u2229',\n  cup: '\\u222A',\n  'int': '\\u222B',\n  there4: '\\u2234',\n  sim: '\\u223C',\n  cong: '\\u2245',\n  asymp: '\\u2248',\n  ne: '\\u2260',\n  equiv: '\\u2261',\n  le: '\\u2264',\n  ge: '\\u2265',\n  sub: '\\u2282',\n  sup: '\\u2283',\n  nsub: '\\u2284',\n  sube: '\\u2286',\n  supe: '\\u2287',\n  oplus: '\\u2295',\n  otimes: '\\u2297',\n  perp: '\\u22A5',\n  sdot: '\\u22C5',\n  lceil: '\\u2308',\n  rceil: '\\u2309',\n  lfloor: '\\u230A',\n  rfloor: '\\u230B',\n  lang: '\\u2329',\n  rang: '\\u232A',\n  loz: '\\u25CA',\n  spades: '\\u2660',\n  clubs: '\\u2663',\n  hearts: '\\u2665',\n  diams: '\\u2666'\n};\n","// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7b9\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Registered plugins\nvar plugins = {};\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n  var reserved = \"\";\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = keywordRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Load plugins\n  this.loadPlugins(options.plugins);\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false;\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0;\n  // Labels in scope.\n  this.labels = [];\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterFunctionScope();\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name]);\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name];\n    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n    plugin(this$1, pluginConfigs[name]);\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this$1.input)[0].length;\n    var match = literal.exec(this$1.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") { return true }\n    start += match[0].length;\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this$1.parseStatement(true, true, exports);\n    node.body.push(stmt);\n  }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function() {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  if (nextCh === 91 || nextCh === 123) { return true } // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet()) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false)\n  case types._class:\n    if (!declaration) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (!declaration && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock()\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (!declaration) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterLexicalScope();\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init)) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next();\n  return this.parseFunction(node, true, false, isAsync)\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.type === types._function);\n  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterLexicalScope();\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this$1.type === types._case || this$1.type === types._default) {\n      var isCase = this$1.type === types._case;\n      if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this$1.startNode());\n      cur.consequent = [];\n      this$1.next();\n      if (isCase) {\n        cur.test = this$1.parseExpression();\n      } else {\n        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this$1.expect(types.colon);\n    } else {\n      if (!cur) { this$1.unexpected(); }\n      cur.consequent.push(this$1.parseStatement(true));\n    }\n  }\n  this.exitLexicalScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      this.enterLexicalScope();\n      this.checkLVal(clause.param, \"let\");\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterLexicalScope();\n    }\n    clause.body = this.parseBlock(false);\n    this.exitLexicalScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this$1.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this$1.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(true);\n  if (node.body.type === \"ClassDeclaration\" ||\n      node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" ||\n      node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async))\n    { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope) {\n  var this$1 = this;\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n\n  var node = this.startNode();\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) {\n    this.enterLexicalScope();\n  }\n  while (!this.eat(types.braceR)) {\n    var stmt = this$1.parseStatement(true);\n    node.body.push(stmt);\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope();\n  }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  if (type === \"ForInStatement\") {\n    if (init.type === \"AssignmentPattern\" ||\n      (init.type === \"VariableDeclaration\" && init.declarations[0].init != null &&\n       (this.strict || init.declarations[0].id.type !== \"Identifier\")))\n      { this.raise(init.start, \"Invalid assignment in for-in loop head\"); }\n  }\n  node.left = init;\n  node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type)\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this$1.startNode();\n    this$1.parseVarId(decl, kind);\n    if (this$1.eat(types.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n    if (!this$1.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom(kind);\n  this.checkLVal(decl.id, kind, false);\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)\n    { node.generator = this.eat(types.star); }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\n    if (node.id) {\n      this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\n    }\n  }\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  if (!isStatement)\n    { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next();\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    var member = this$1.parseClassMember(classBody);\n    if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n      if (hadConstructor) { this$1.raise(member.start, \"Duplicate constructor in the same class\"); }\n      hadConstructor = true;\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassMember = function(classBody) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) { return null }\n\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n    var start = this$1.start, startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) { return false }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n    if (method.key) { this$1.unexpected(); }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) { this.parsePropertyName(method); }\n  var key = method.key;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n      key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    method.kind = \"constructor\";\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(classBody, method, isGenerator, isAsync);\n  if (method.kind === \"get\" && method.value.params.length !== 0)\n    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && method.value.params.length !== 1)\n    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n  return method\n};\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      // check for keywords used as local names\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        var spec = list[i];\n\n        this$1.checkUnreserved(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this$1.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this$1.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n  else if (type === \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this$1.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this$1.startNode();\n    node.local = this$1.parseIdent(true);\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n    this$1.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, \"let\");\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, \"let\");\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this$1.startNode();\n    node$2.imported = this$1.parseIdent(true);\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent();\n    } else {\n      this$1.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this$1.checkLVal(node$2.local, \"let\");\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function(statement) {\n  return (\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this$1.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this$1.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding);\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this$1.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this$1.expect(types.comma); }\n    if (allowEmpty && this$1.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === types.ellipsis) {\n      var rest = this$1.parseRestBinding();\n      this$1.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n      this$1.expect(close);\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n      this$1.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType && bindingType !== \"none\") {\n      if (\n        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n      ) {\n        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n      }\n      if (bindingType === \"var\") {\n        this.declareVarName(expr.name);\n      } else {\n        this.declareLexicalName(expr.name);\n      }\n    }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this$1.checkLVal(prop, bindingType, checkClashes);\n  }\n    break\n\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLVal(expr.value, bindingType, checkClashes);\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n        // Backwards-compat kludge. Can be removed in version 6.0\n        else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types.parenL || this.type === types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.operator = this$1.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this$1.checkLVal(expr);\n      this$1.next();\n      expr = this$1.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n  for (var computed = (void 0);;) {\n    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n      node.computed = !!computed;\n      if (computed) { this$1.expect(types.bracketR); }\n      base = this$1.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this$1.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\n      this$1.yieldPos = 0;\n      this$1.awaitPos = 0;\n      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false);\n        this$1.checkYieldAwaitInDefaultParams();\n        this$1.yieldPos = oldYieldPos;\n        this$1.awaitPos = oldAwaitPos;\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true);\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this$1.finishNode(node$1, \"CallExpression\");\n    } else if (this$1.type === types.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this$1.parseTemplate({isTagged: true});\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n    } else {\n      return base\n    }\n  }\n};\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.inFunction)\n      { this.raise(this.start, \"'super' outside of function or class\"); }\n    node = this.startNode();\n    this.next();\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super Arguments\n    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(this.type !== types.name);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n        id = this.parseIdent();\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, false)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    while (this.type !== types.parenR) {\n      first ? first = false : this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this$1.type === types.ellipsis) {\n        spreadStart = this$1.start;\n        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\n        if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\" || containsEsc)\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n    if (!this.inFunction)\n      { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  var this$1 = this;\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this$1.type === types.eof) { this$1.raise(this$1.pos, \"Unterminated template literal\"); }\n    this$1.expect(types.dollarBraceL);\n    node.expressions.push(this$1.parseExpression());\n    this$1.expect(types.braceR);\n    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types.comma && this.type !== types.braceR)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    this.checkUnreserved(prop.key);\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.enterFunctionScope();\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = false;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitFunctionScope();\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\");\n  }\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var this$1 = this;\n\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this$1.type === types.comma)\n      { elt = null; }\n    else if (this$1.type === types.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this$1.start; }\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n  if (this.isKeyword(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (liberal && this.options.allowReserved === \"never\") { liberal = false; }\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) { this.checkUnreserved(node); }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\n// Object.assign polyfill\nvar assign = Object.assign || function(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0, list = sources; i < list.length; i += 1) {\n    var source = list[i];\n\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterFunctionScope = function() {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n};\n\npp$5.exitFunctionScope = function() {\n  this.scopeStack.pop();\n};\n\npp$5.enterLexicalScope = function() {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n\n  this.scopeStack.push(childScope);\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n};\n\npp$5.exitLexicalScope = function() {\n  var childScope = this.scopeStack.pop();\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  assign(parentScope.childVar, childScope.var, childScope.childVar);\n};\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp$5.canDeclareVarName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n};\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp$5.canDeclareLexicalName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n};\n\npp$5.declareVarName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n};\n\npp$5.declareLexicalName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType === types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n    { return true }\n  if (prevType === types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType === types._var || prevType === types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  var this$1 = this;\n\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this$1.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\nvar data = {\n  \"$LONE\": [\n    \"ASCII\",\n    \"ASCII_Hex_Digit\",\n    \"AHex\",\n    \"Alphabetic\",\n    \"Alpha\",\n    \"Any\",\n    \"Assigned\",\n    \"Bidi_Control\",\n    \"Bidi_C\",\n    \"Bidi_Mirrored\",\n    \"Bidi_M\",\n    \"Case_Ignorable\",\n    \"CI\",\n    \"Cased\",\n    \"Changes_When_Casefolded\",\n    \"CWCF\",\n    \"Changes_When_Casemapped\",\n    \"CWCM\",\n    \"Changes_When_Lowercased\",\n    \"CWL\",\n    \"Changes_When_NFKC_Casefolded\",\n    \"CWKCF\",\n    \"Changes_When_Titlecased\",\n    \"CWT\",\n    \"Changes_When_Uppercased\",\n    \"CWU\",\n    \"Dash\",\n    \"Default_Ignorable_Code_Point\",\n    \"DI\",\n    \"Deprecated\",\n    \"Dep\",\n    \"Diacritic\",\n    \"Dia\",\n    \"Emoji\",\n    \"Emoji_Component\",\n    \"Emoji_Modifier\",\n    \"Emoji_Modifier_Base\",\n    \"Emoji_Presentation\",\n    \"Extender\",\n    \"Ext\",\n    \"Grapheme_Base\",\n    \"Gr_Base\",\n    \"Grapheme_Extend\",\n    \"Gr_Ext\",\n    \"Hex_Digit\",\n    \"Hex\",\n    \"IDS_Binary_Operator\",\n    \"IDSB\",\n    \"IDS_Trinary_Operator\",\n    \"IDST\",\n    \"ID_Continue\",\n    \"IDC\",\n    \"ID_Start\",\n    \"IDS\",\n    \"Ideographic\",\n    \"Ideo\",\n    \"Join_Control\",\n    \"Join_C\",\n    \"Logical_Order_Exception\",\n    \"LOE\",\n    \"Lowercase\",\n    \"Lower\",\n    \"Math\",\n    \"Noncharacter_Code_Point\",\n    \"NChar\",\n    \"Pattern_Syntax\",\n    \"Pat_Syn\",\n    \"Pattern_White_Space\",\n    \"Pat_WS\",\n    \"Quotation_Mark\",\n    \"QMark\",\n    \"Radical\",\n    \"Regional_Indicator\",\n    \"RI\",\n    \"Sentence_Terminal\",\n    \"STerm\",\n    \"Soft_Dotted\",\n    \"SD\",\n    \"Terminal_Punctuation\",\n    \"Term\",\n    \"Unified_Ideograph\",\n    \"UIdeo\",\n    \"Uppercase\",\n    \"Upper\",\n    \"Variation_Selector\",\n    \"VS\",\n    \"White_Space\",\n    \"space\",\n    \"XID_Continue\",\n    \"XIDC\",\n    \"XID_Start\",\n    \"XIDS\"\n  ],\n  \"General_Category\": [\n    \"Cased_Letter\",\n    \"LC\",\n    \"Close_Punctuation\",\n    \"Pe\",\n    \"Connector_Punctuation\",\n    \"Pc\",\n    \"Control\",\n    \"Cc\",\n    \"cntrl\",\n    \"Currency_Symbol\",\n    \"Sc\",\n    \"Dash_Punctuation\",\n    \"Pd\",\n    \"Decimal_Number\",\n    \"Nd\",\n    \"digit\",\n    \"Enclosing_Mark\",\n    \"Me\",\n    \"Final_Punctuation\",\n    \"Pf\",\n    \"Format\",\n    \"Cf\",\n    \"Initial_Punctuation\",\n    \"Pi\",\n    \"Letter\",\n    \"L\",\n    \"Letter_Number\",\n    \"Nl\",\n    \"Line_Separator\",\n    \"Zl\",\n    \"Lowercase_Letter\",\n    \"Ll\",\n    \"Mark\",\n    \"M\",\n    \"Combining_Mark\",\n    \"Math_Symbol\",\n    \"Sm\",\n    \"Modifier_Letter\",\n    \"Lm\",\n    \"Modifier_Symbol\",\n    \"Sk\",\n    \"Nonspacing_Mark\",\n    \"Mn\",\n    \"Number\",\n    \"N\",\n    \"Open_Punctuation\",\n    \"Ps\",\n    \"Other\",\n    \"C\",\n    \"Other_Letter\",\n    \"Lo\",\n    \"Other_Number\",\n    \"No\",\n    \"Other_Punctuation\",\n    \"Po\",\n    \"Other_Symbol\",\n    \"So\",\n    \"Paragraph_Separator\",\n    \"Zp\",\n    \"Private_Use\",\n    \"Co\",\n    \"Punctuation\",\n    \"P\",\n    \"punct\",\n    \"Separator\",\n    \"Z\",\n    \"Space_Separator\",\n    \"Zs\",\n    \"Spacing_Mark\",\n    \"Mc\",\n    \"Surrogate\",\n    \"Cs\",\n    \"Symbol\",\n    \"S\",\n    \"Titlecase_Letter\",\n    \"Lt\",\n    \"Unassigned\",\n    \"Cn\",\n    \"Uppercase_Letter\",\n    \"Lu\"\n  ],\n  \"Script\": [\n    \"Adlam\",\n    \"Adlm\",\n    \"Ahom\",\n    \"Anatolian_Hieroglyphs\",\n    \"Hluw\",\n    \"Arabic\",\n    \"Arab\",\n    \"Armenian\",\n    \"Armn\",\n    \"Avestan\",\n    \"Avst\",\n    \"Balinese\",\n    \"Bali\",\n    \"Bamum\",\n    \"Bamu\",\n    \"Bassa_Vah\",\n    \"Bass\",\n    \"Batak\",\n    \"Batk\",\n    \"Bengali\",\n    \"Beng\",\n    \"Bhaiksuki\",\n    \"Bhks\",\n    \"Bopomofo\",\n    \"Bopo\",\n    \"Brahmi\",\n    \"Brah\",\n    \"Braille\",\n    \"Brai\",\n    \"Buginese\",\n    \"Bugi\",\n    \"Buhid\",\n    \"Buhd\",\n    \"Canadian_Aboriginal\",\n    \"Cans\",\n    \"Carian\",\n    \"Cari\",\n    \"Caucasian_Albanian\",\n    \"Aghb\",\n    \"Chakma\",\n    \"Cakm\",\n    \"Cham\",\n    \"Cherokee\",\n    \"Cher\",\n    \"Common\",\n    \"Zyyy\",\n    \"Coptic\",\n    \"Copt\",\n    \"Qaac\",\n    \"Cuneiform\",\n    \"Xsux\",\n    \"Cypriot\",\n    \"Cprt\",\n    \"Cyrillic\",\n    \"Cyrl\",\n    \"Deseret\",\n    \"Dsrt\",\n    \"Devanagari\",\n    \"Deva\",\n    \"Duployan\",\n    \"Dupl\",\n    \"Egyptian_Hieroglyphs\",\n    \"Egyp\",\n    \"Elbasan\",\n    \"Elba\",\n    \"Ethiopic\",\n    \"Ethi\",\n    \"Georgian\",\n    \"Geor\",\n    \"Glagolitic\",\n    \"Glag\",\n    \"Gothic\",\n    \"Goth\",\n    \"Grantha\",\n    \"Gran\",\n    \"Greek\",\n    \"Grek\",\n    \"Gujarati\",\n    \"Gujr\",\n    \"Gurmukhi\",\n    \"Guru\",\n    \"Han\",\n    \"Hani\",\n    \"Hangul\",\n    \"Hang\",\n    \"Hanunoo\",\n    \"Hano\",\n    \"Hatran\",\n    \"Hatr\",\n    \"Hebrew\",\n    \"Hebr\",\n    \"Hiragana\",\n    \"Hira\",\n    \"Imperial_Aramaic\",\n    \"Armi\",\n    \"Inherited\",\n    \"Zinh\",\n    \"Qaai\",\n    \"Inscriptional_Pahlavi\",\n    \"Phli\",\n    \"Inscriptional_Parthian\",\n    \"Prti\",\n    \"Javanese\",\n    \"Java\",\n    \"Kaithi\",\n    \"Kthi\",\n    \"Kannada\",\n    \"Knda\",\n    \"Katakana\",\n    \"Kana\",\n    \"Kayah_Li\",\n    \"Kali\",\n    \"Kharoshthi\",\n    \"Khar\",\n    \"Khmer\",\n    \"Khmr\",\n    \"Khojki\",\n    \"Khoj\",\n    \"Khudawadi\",\n    \"Sind\",\n    \"Lao\",\n    \"Laoo\",\n    \"Latin\",\n    \"Latn\",\n    \"Lepcha\",\n    \"Lepc\",\n    \"Limbu\",\n    \"Limb\",\n    \"Linear_A\",\n    \"Lina\",\n    \"Linear_B\",\n    \"Linb\",\n    \"Lisu\",\n    \"Lycian\",\n    \"Lyci\",\n    \"Lydian\",\n    \"Lydi\",\n    \"Mahajani\",\n    \"Mahj\",\n    \"Malayalam\",\n    \"Mlym\",\n    \"Mandaic\",\n    \"Mand\",\n    \"Manichaean\",\n    \"Mani\",\n    \"Marchen\",\n    \"Marc\",\n    \"Masaram_Gondi\",\n    \"Gonm\",\n    \"Meetei_Mayek\",\n    \"Mtei\",\n    \"Mende_Kikakui\",\n    \"Mend\",\n    \"Meroitic_Cursive\",\n    \"Merc\",\n    \"Meroitic_Hieroglyphs\",\n    \"Mero\",\n    \"Miao\",\n    \"Plrd\",\n    \"Modi\",\n    \"Mongolian\",\n    \"Mong\",\n    \"Mro\",\n    \"Mroo\",\n    \"Multani\",\n    \"Mult\",\n    \"Myanmar\",\n    \"Mymr\",\n    \"Nabataean\",\n    \"Nbat\",\n    \"New_Tai_Lue\",\n    \"Talu\",\n    \"Newa\",\n    \"Nko\",\n    \"Nkoo\",\n    \"Nushu\",\n    \"Nshu\",\n    \"Ogham\",\n    \"Ogam\",\n    \"Ol_Chiki\",\n    \"Olck\",\n    \"Old_Hungarian\",\n    \"Hung\",\n    \"Old_Italic\",\n    \"Ital\",\n    \"Old_North_Arabian\",\n    \"Narb\",\n    \"Old_Permic\",\n    \"Perm\",\n    \"Old_Persian\",\n    \"Xpeo\",\n    \"Old_South_Arabian\",\n    \"Sarb\",\n    \"Old_Turkic\",\n    \"Orkh\",\n    \"Oriya\",\n    \"Orya\",\n    \"Osage\",\n    \"Osge\",\n    \"Osmanya\",\n    \"Osma\",\n    \"Pahawh_Hmong\",\n    \"Hmng\",\n    \"Palmyrene\",\n    \"Palm\",\n    \"Pau_Cin_Hau\",\n    \"Pauc\",\n    \"Phags_Pa\",\n    \"Phag\",\n    \"Phoenician\",\n    \"Phnx\",\n    \"Psalter_Pahlavi\",\n    \"Phlp\",\n    \"Rejang\",\n    \"Rjng\",\n    \"Runic\",\n    \"Runr\",\n    \"Samaritan\",\n    \"Samr\",\n    \"Saurashtra\",\n    \"Saur\",\n    \"Sharada\",\n    \"Shrd\",\n    \"Shavian\",\n    \"Shaw\",\n    \"Siddham\",\n    \"Sidd\",\n    \"SignWriting\",\n    \"Sgnw\",\n    \"Sinhala\",\n    \"Sinh\",\n    \"Sora_Sompeng\",\n    \"Sora\",\n    \"Soyombo\",\n    \"Soyo\",\n    \"Sundanese\",\n    \"Sund\",\n    \"Syloti_Nagri\",\n    \"Sylo\",\n    \"Syriac\",\n    \"Syrc\",\n    \"Tagalog\",\n    \"Tglg\",\n    \"Tagbanwa\",\n    \"Tagb\",\n    \"Tai_Le\",\n    \"Tale\",\n    \"Tai_Tham\",\n    \"Lana\",\n    \"Tai_Viet\",\n    \"Tavt\",\n    \"Takri\",\n    \"Takr\",\n    \"Tamil\",\n    \"Taml\",\n    \"Tangut\",\n    \"Tang\",\n    \"Telugu\",\n    \"Telu\",\n    \"Thaana\",\n    \"Thaa\",\n    \"Thai\",\n    \"Tibetan\",\n    \"Tibt\",\n    \"Tifinagh\",\n    \"Tfng\",\n    \"Tirhuta\",\n    \"Tirh\",\n    \"Ugaritic\",\n    \"Ugar\",\n    \"Vai\",\n    \"Vaii\",\n    \"Warang_Citi\",\n    \"Wara\",\n    \"Yi\",\n    \"Yiii\",\n    \"Zanabazar_Square\",\n    \"Zanb\"\n  ]\n};\nArray.prototype.push.apply(data.$LONE, data.General_Category);\ndata.gc = data.General_Category;\ndata.sc = data.Script_Extensions = data.scx = data.Script;\n\nvar pp$9 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i);\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current () {\n  return this.at(this.pos)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead () {\n  return this.at(this.nextIndex(this.pos))\n};\n\nRegExpValidationState.prototype.advance = function advance () {\n  this.pos = this.nextIndex(this.pos);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch) {\n  if (this.current() === ch) {\n    this.advance();\n    return true\n  }\n  return false\n};\n\nfunction codePointToString$1(ch) {\n  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$9.validateRegExpFlags = function(state) {\n  var this$1 = this;\n\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this$1.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this$1.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$9.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$9.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$9.regexp_disjunction = function(state) {\n  var this$1 = this;\n\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this$1.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$9.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    {  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$9.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$9.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$9.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$9.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$9.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$9.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$9.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$9.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$9.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$9.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$9.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$9.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier[U] ::\n//   [empty]\n//   `?` GroupName[?U]\npp$9.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName[U] ::\n//   `<` RegExpIdentifierName[?U] `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$9.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName[U] ::\n//   RegExpIdentifierStart[?U]\n//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$9.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString$1(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString$1(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart[U] ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\npp$9.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart[U] ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n//   <ZWNJ>\n//   <ZWJ>\npp$9.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$9.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$9.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$9.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$9.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$9.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$9.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      state.switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$9.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$9.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$9.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true\n  }\n\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatUnicodePropertyValueExpression(state) &&\n      state.eat(0x7D /* } */)\n    ) {\n      return true\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return false\n};\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$9.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true\n  }\n  return false\n};\npp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\npp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (data.$LONE.indexOf(nameOrValue) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$9.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$9.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$9.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* [ */)) {\n      return true\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$9.regexp_classRanges = function(state) {\n  var this$1 = this;\n\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$9.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* [ */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$9.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$9.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$9.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$9.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$9.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$9.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$9.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$8 = Parser.prototype;\n\n// Move to the next token\n\npp$8.next = function() {\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$8.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$8[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$8.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$8.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$8.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$8.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$8.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine;\n      this$1.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$8.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this$1.input.charCodeAt(++this$1.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$8.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this$1.pos;\n      break\n    case 13:\n      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n        ++this$1.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this$1.pos;\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n      case 42: // '*'\n        this$1.skipBlockComment();\n        break\n      case 47:\n        this$1.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this$1.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$8.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$8.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$8.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$8.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$8.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$8.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$8.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$8.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$8.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$8.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n  case 63: ++this.pos; return this.finishToken(types.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp$8.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp$8.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(start, \"Unterminated regular expression\"); }\n    var ch = this$1.input.charAt(this$1.pos);\n    if (lineBreak.test(ch)) { this$1.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this$1.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$8.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    ++this$1.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\npp$8.readRadixNumber = function(radix) {\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$8.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  var next = this.input.charCodeAt(this.pos);\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var str = this.input.slice(start, this.pos);\n  var val = octal ? parseInt(str, 8) : parseFloat(str);\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$8.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$8.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(false);\n      chunkStart = this$1.pos;\n    } else {\n      if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n      ++this$1.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$8.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$8.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$8.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated template\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this$1.pos += 2;\n          return this$1.finishToken(types.dollarBraceL)\n        } else {\n          ++this$1.pos;\n          return this$1.finishToken(types.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      return this$1.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(true);\n      chunkStart = this$1.pos;\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      ++this$1.pos;\n      switch (ch) {\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      chunkStart = this$1.pos;\n    } else {\n      ++this$1.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$8.readInvalidTemplateToken = function() {\n  var this$1 = this;\n\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this$1.input[this$1.pos]) {\n    case \"\\\\\":\n      ++this$1.pos;\n      break\n\n    case \"$\":\n      if (this$1.input[this$1.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$8.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$8.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$8.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true;\n      word += this$1.input.slice(chunkStart, this$1.pos);\n      var escStart = this$1.pos;\n      if (this$1.input.charCodeAt(++this$1.pos) !== 117) // \"u\"\n        { this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this$1.pos;\n      var esc = this$1.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this$1.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString(esc);\n      chunkStart = this$1.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$8.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"5.7.3\";\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nvar parse_dammit;\nvar LooseParser;\nvar pluginsLoose; // eslint-disable-line camelcase\nfunction addLooseExports(parse, Parser$$1, plugins$$1) {\n  parse_dammit = parse; // eslint-disable-line camelcase\n  LooseParser = Parser$$1;\n  pluginsLoose = plugins$$1;\n}\n\nexport { version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };\n","export default {\n  class:     'className',\n  for:       'htmlFor',\n  maxlength: 'maxLength',\n\n  colspan: 'colSpan',\n  rowspan: 'rowSpan',\n}\n","const VOID_ELEMENTS = [\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'menuitem',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n]\n\nconst NO_WHITESPACE = [\n  'table',\n  'tbody',\n  'tfoot',\n  'thead',\n  'tr',\n]\n\nexport default VOID_ELEMENTS\n\nexport function canHaveChildren(tagName) {\n  return VOID_ELEMENTS.indexOf(tagName.toLowerCase()) === -1\n}\nexport function canHaveWhitespace(tagName) {\n  return NO_WHITESPACE.indexOf(tagName.toLowerCase()) !== -1\n}\n","export default function hash(value = '', radix = 16) {\n  const string = String(value)\n  let h = 0\n  string.split('').forEach((char) => {\n    /* eslint-disable no-bitwise */\n    h = ((h << 5) - h) + char.charCodeAt(0)\n    h &= h // Convert to 32-bit integer\n    /* eslint-enable no-bitwise */\n  })\n  return Math.abs(h).toString(radix)\n}\n\nexport const randomHash = () => hash(Math.random().toString())","import camelCase from './camelCase'\n\nexport default function parseStyle(style) {\n  switch (typeof style) {\n    case 'string':\n      return style.split(';').filter(r => r)\n        .reduce((map, rule) => {\n          const name = rule.slice(0, rule.indexOf(':')).trim()\n          const value = rule.slice(rule.indexOf(':') + 1).trim()\n\n          return {\n            ...map,\n            [camelCase(name)]: value,\n          }\n        }, {})\n    case 'object':\n      return style\n\n    default:\n      return undefined\n  }\n}\n","export default function camelCase(string) {\n  return string\n    .replace(/([A-Z])([A-Z])/g, '$1 $2')\n    .replace(/([a-z])([A-Z])/g, '$1 $2')\n    .replace(/[^a-zA-Z\\u00C0-\\u00ff]/g, ' ')\n    .toLowerCase()\n    .split(' ')\n    .filter(value => value)\n    .map((s, i) => (i > 0 ? s[0].toUpperCase() + s.slice(1) : s))\n    .join('')\n}\n","const pathToArrayPath = (path) => {\n  if (path == null || path === '') return []\n  return path.split('.')\n}\n\nconst resolveArrayPath = (object, path) => {\n  const [property, ...subPath] = path\n  if (object == null || property == null) {\n    return undefined\n  }\n  return subPath.length === 0\n    ? object[property]\n    : resolveArrayPath(object[property], subPath)\n}\n\nexport default (object, path) => resolveArrayPath(object, pathToArrayPath(path))\n","/* eslint-disable no-console */\nimport { Parser } from 'acorn-jsx'\nimport React, { Component, Fragment } from 'react'\nimport ATTRIBUTES from '../constants/attributeNames'\nimport { canHaveChildren, canHaveWhitespace } from '../constants/specialTags'\nimport { randomHash } from '../helpers/hash'\nimport parseStyle from '../helpers/parseStyle'\nimport resolvePath from '../helpers/resolvePath'\n\nconst parserOptions = { plugins: { jsx: true } }\n\n/* eslint-disable consistent-return */\nexport default class JsxParser extends Component {\n  static displayName = 'JsxParser'\n\n  static defaultProps = {\n    allowUnknownElements: true,\n    bindings: {},\n    blacklistedAttrs: [/^on.+/i],\n    blacklistedTags: ['script'],\n    components: [],\n    componentsOnly: false,\n    disableFragments: false,\n    disableKeyGeneration: false,\n    jsx: '',\n    onError: () => { },\n    showWarnings: false,\n    renderInWrapper: true,\n  }\n\n  parseJSX = (rawJSX) => {\n    const wrappedJsx = `<root>${rawJSX}</root>`\n    let parsed = []\n    try {\n      parsed = (new Parser(parserOptions, wrappedJsx)).parse()\n      parsed = parsed.body[0].expression.children || []\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      if (this.props.showWarnings) console.warn(error)\n      if (this.props.onError) this.props.onError(error)\n      return []\n    }\n\n    return parsed.map(this.parseExpression).filter(Boolean)\n  }\n\n  parseExpression = (expression) => {\n    console.log('expression', expression)\n    try {\n      switch (expression.type) {\n        case 'JSXElement':\n          return this.parseElement(expression)\n        case 'JSXText':\n          const key = this.props.disableKeyGeneration ? undefined : randomHash()\n          return this.props.disableFragments\n            ? expression.value\n            : <Fragment key={key}>{expression.value}</Fragment>\n        case 'JSXAttribute':\n          if (expression.value === null) return true\n          return this.parseExpression(expression.value)\n        case 'ConditionalExpression':\n          return this.parseExpression(expression.test)\n            ? this.parseExpression(expression.consequent)\n            : this.parseExpression(expression.alternate)\n        case 'ArrayExpression':\n          return expression.elements.map(this.parseExpression)\n        case 'ObjectExpression':\n          const object = {}\n          expression.properties.forEach((prop) => {\n            object[prop.key.name || prop.key.value] = this.parseExpression(prop.value)\n          })\n          return object\n        case 'Identifier':\n          return (this.props.bindings || {})[expression.name]\n        case 'JSXExpressionContainer':\n          return this.parseExpression(expression.expression)\n        case 'Literal':\n          return expression.value\n        case 'MemberExpression':\n          return (this.parseExpression(expression.object) || {})[expression.property.name]\n        case 'CallExpression':\n          const parsedCallee = this.parseExpression(expression.callee)\n          if (parsedCallee === undefined) {\n            this.props.onError(new Error(`The expression '${expression.callee}' could not be resolved, resulting in an undefined return value.`))\n            return undefined\n          }\n          return parsedCallee(...expression.arguments.map(this.parseExpression))\n        case 'LogicalExpression':\n          const left = this.parseExpression(expression.left)\n          if (expression.operator === '||' && left) return true\n          if ((expression.operator === '&&' && left) || (expression.operator === '||' && !left)) {\n            return this.parseExpression(expression.right)\n          }\n          return false\n        case 'BinaryExpression':\n          /* eslint-disable eqeqeq,max-len */\n          switch (expression.operator) {\n            case '+':\n              return this.parseExpression(expression.left) + this.parseExpression(expression.right)\n            case '-':\n              return this.parseExpression(expression.left) - this.parseExpression(expression.right)\n            case '*':\n              return this.parseExpression(expression.left) * this.parseExpression(expression.right)\n            case '/':\n              return this.parseExpression(expression.left) / this.parseExpression(expression.right)\n            case '==':\n              return (this.parseExpression(expression.left) == this.parseExpression(expression.right)).toString()\n            case '!=':\n              return this.parseExpression(expression.left) != this.parseExpression(expression.right)\n            case '===':\n              return this.parseExpression(expression.left) === this.parseExpression(expression.right)\n            case '!==':\n              return this.parseExpression(expression.left) !== this.parseExpression(expression.right)\n          /* eslint-enable eqeqeq,max-len */\n          } break\n        case 'UnaryExpression':\n          switch (expression.operator) {\n            case '+':\n              return expression.argument.value\n            case '-':\n              return -1 * expression.argument.value\n            case '!':\n              return (!expression.argument.value).toString()\n          }\n      }\n    } catch (error) {\n      console.log('expression error', error)\n    }\n  }\n\n  parseName = (element) => {\n    switch (element.type) {\n      case 'JSXIdentifier':\n        return element.name\n      case 'JSXMemberExpression':\n        return `${this.parseName(element.object)}.${this.parseName(element.property)}`\n    }\n  }\n\n  parseElement = (element) => {\n    const {\n allowUnknownElements, components = {}, componentsOnly, onError \n} = this.props\n    const { children: childNodes = [], openingElement } = element\n    const { attributes = [] } = openingElement\n    const name = this.parseName(openingElement.name)\n    if (!name) {\n      onError(new Error(`The <${openingElement.name}> tag could not be parsed, and will not be rendered.`))\n      return undefined\n    }\n\n    const blacklistedAttrs = (this.props.blacklistedAttrs || [])\n      .map(attr => (attr instanceof RegExp ? attr : new RegExp(attr, 'i')))\n    const blacklistedTags = (this.props.blacklistedTags || [])\n      .map(tag => tag.trim().toLowerCase()).filter(Boolean)\n\n    if (/^(html|head|body)$/i.test(name)) return childNodes.map(c => this.parseElement(c))\n    const tagName = name.trim().toLowerCase()\n    if (blacklistedTags.indexOf(tagName) !== -1) {\n      onError(new Error(`The tag <${name}> is blacklisted, and will not be rendered.`))\n      return undefined\n    }\n\n    if (!resolvePath(components, name)) {\n      if (componentsOnly) {\n        onError(new Error(`The componenet <${name}> is unrecognized, and will not be rendered.`))\n        return undefined\n      }\n\n      if (!allowUnknownElements && document.createElement(name) instanceof HTMLUnknownElement) {\n        onError(new Error(`The tag <${name}> is unrecognized in this browser, and will not be rendered.`))\n        return undefined\n      }\n    }\n\n    let children\n    const component = resolvePath(components, name)\n    if (component || canHaveChildren(name)) {\n      children = childNodes.map(this.parseExpression)\n      if (!component && !canHaveWhitespace(name)) {\n        children = children.filter(child => (\n          typeof child !== 'string' || !/^\\s*$/.test(child)\n        ))\n      }\n\n      if (children.length === 0) {\n        children = undefined\n      } else if (children.length === 1) {\n        [children] = children\n      }\n    }\n\n    const props = {\n      key: this.props.disableKeyGeneration ? undefined : randomHash(),\n    }\n    attributes.forEach((expr) => {\n      if (expr.type === 'JSXAttribute') {\n        const rawName = expr.name.name\n        const attributeName = ATTRIBUTES[rawName] || rawName\n        // if the value is null, this is an implicitly \"true\" prop, such as readOnly\n        const value = this.parseExpression(expr)\n\n        const matches = blacklistedAttrs.filter(re => re.test(attributeName))\n        if (matches.length === 0) {\n          if (value === 'true' || value === 'false') {\n            props[attributeName] = (value === 'true')\n          } else {\n            props[attributeName] = value\n          }\n        }\n      } else if (\n        (expr.type === 'JSXSpreadAttribute' && expr.argument.type === 'Identifier')\n        || expr.argument.type === 'MemberExpression'\n      ) {\n        const value = this.parseExpression(expr.argument)\n        if (typeof value === 'object') {\n          Object.keys(value).forEach((rawName) => {\n            const attributeName = ATTRIBUTES[rawName] || rawName\n            const matches = blacklistedAttrs.filter(re => re.test(attributeName))\n            if (matches.length === 0) {\n              props[attributeName] = value[rawName]\n            }\n          })\n        }\n      }\n    })\n\n    if (typeof props.style === 'string') {\n      props.style = parseStyle(props.style)\n    }\n\n    if (children) props.children = children\n\n    return React.createElement(component || name.toLowerCase(), props)\n  }\n\n  render = () => {\n    const jsx = (this.props.jsx || '').trim().replace(/<!DOCTYPE([^>]*)>/g, '')\n    this.ParsedChildren = this.parseJSX(jsx)\n\n    return (\n      this.props.renderInWrapper\n        ? <div className=\"jsx-parser\">{this.ParsedChildren}</div>\n        : <>{this.ParsedChildren}</>\n    )\n  }\n}\n/* eslint-enable consistent-return */\n\nif (process.env.NODE_ENV !== 'production') {\n  /* eslint-disable react/no-unused-prop-types */\n  // eslint-disable-next-line global-require,import/no-extraneous-dependencies\n  const PropTypes = require('prop-types')\n  JsxParser.propTypes = {\n    allowUnknownElements: PropTypes.bool,\n    bindings: PropTypes.shape({}),\n    blacklistedAttrs: PropTypes.arrayOf(PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.instanceOf(RegExp),\n    ])),\n    blacklistedTags: PropTypes.arrayOf(PropTypes.string),\n    components: PropTypes.shape({}),\n    componentsOnly: PropTypes.bool,\n    disableFragments: PropTypes.bool,\n    disableKeyGeneration: PropTypes.bool,\n    jsx: PropTypes.string,\n    onError: PropTypes.func,\n    showWarnings: PropTypes.bool,\n    renderInWrapper: PropTypes.bool,\n  }\n}\n"],"sourceRoot":""}